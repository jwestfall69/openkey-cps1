/*
 This is used to generate cps1_configs.h included by openkey-cps1.ino.  Its
 taking the human readable config settings and converting them into a byte
 array that openkey-cps1 can send directly to the B-21 chip without any
 pre-processing.

 if you make a change, be sure to run 'make run' to regenerate the include file
 $ make run
 ./gen-cps1-configs > ../openkey-cps1/cps1-configs.h

*/

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define CONFIG_MAX    27
#define CONFIG_SIZE   18

void print_jumper(uint8_t value);
void print_config(void);
void reset_config(void);
void add_bits(uint16_t data, int8_t num_bits);
void add_addr(uint8_t addr);

uint8_t config_raw[CONFIG_SIZE];
uint8_t config_raw_offset;
uint8_t config_raw_byte;
uint8_t config_raw_bits;

uint16_t masks[16] = {
  0x0001, 0x0002, 0x0004, 0x0008,
  0x0010, 0x0020, 0x0040, 0x0080,
  0x0100, 0x0200, 0x0400, 0x0800,
  0x1000, 0x2000, 0x4000, 0x8000,
};

// This struct is a combination of mame source code and
// https://gitlab.com/loic.petit/cps2-reverse/-/blob/master/DLs/DL-0921/doc/configuration-key.md
typedef struct chip_config_t {
  uint8_t cps_id_addr;
  uint16_t cps_id_value;

  uint8_t multi_factor_x_addr;
  uint8_t multi_factor_y_addr;
  uint8_t multi_result_lsb_addr;
  uint8_t multi_result_msb_addr;
  uint8_t multi_tc_addr;          // unknown1 in mame

  uint8_t check1_addr;            // unknown2 in mame
  uint8_t check2_addr;            // unknown3 in mame

  // not in mame
  uint16_t check1_value;
  uint16_t check2_value;

  uint8_t layer_ctrl_addr;

  uint8_t priority1_addr;
  uint8_t priority2_addr;
  uint8_t priority3_addr;
  uint8_t priority4_addr;

  uint8_t palette_ctrl_addr;

  // layer masks are 3 bits
  // sounds like the values in mame should really only be a single bit, but
  // in some cases multiple bits are set.  not 100% clear on those, just have
  // to guess until they can be tested.
  //   mame => what should be used
  //   0x01 = 0x0
  //   0x02 = 0x1
  //   0x04 = 0x2
  //   0x08 = 0x3
  //   0x0a = ???
  //   0x10 = 0x4
  //   0x12 = 0x4 ??
  //   0x14 = 0x4 ??
  //   0x16 = 0x4 ??
  //   0x20 = 0x5
  //   0x30 = ???
  //   0x40 = 0x6
  //   0x80 = 0x7
  uint8_t layer1_mask;
  uint8_t layer2_mask;
  uint8_t layer3_mask;
  uint8_t layer4_mask;
  uint8_t layer5_mask;

  // not in mame
  uint8_t raster1_addr;
  uint8_t raster2_addr;
  uint8_t raster3_addr;

  char comment[256];
} chip_config;


// Data comes from a combination of:
// https://github.com/ArcadeHacker/ArcadeHacker_CPS1/blob/6c506ff339f6a3df2e9696afbf5ec2615eeb207d/ArcadeHacker_CPS1.ino#L43
// https://github.com/mamedev/mame/blob/master/src/mame/capcom/cps1_v.cpp#L472
// https://gitlab.com/loic.petit/cps2-reverse/-/blob/master/DLs/DL-0921/doc/configuration-key.md
//  - addr's will get >> 1 before we write out to make it easier to compare with mame
//  - unused addr's are set to 0xff to make them easy to identify
chip_config chip_configs[CONFIG_MAX] = {
   // cps id            multi x/y/lsb/msb/tc         check1/2     check1/2 value  layer ctrl         priorities          pal ctrl     layer masks (converted)        rasters        P ROM  CPS_B_XX     some games that use it
  { 0xff, 0x0000,   0x06, 0x04, 0x02, 0x00, 0x0e,   0x0c, 0x0a,   0x0a47, 0x205c,   0x20,      0x2e, 0x2c, 0x2a, 0x28,     0x30,      0x5, 0x4, 0x4, 0x0, 0x0,   0xff, 0xff, 0xff, "[CCx ] CPS_B_21_BT3 Captain Commando" },
  { 0xff, 0x0000,   0x1e, 0x1c, 0x1a, 0x18, 0xff,   0x0c, 0x0a,   0x1d6b, 0x21c2,   0x20,      0x2e, 0x2c, 0x2a, 0x28,     0x30,      0x4, 0x3, 0x4, 0x0, 0x0,   0xff, 0xff, 0xff, "[KDx ] CPS_B_21_BT2 The King of Dragons" },
  { 0xff, 0x0000,   0x06, 0x04, 0x02, 0x00, 0x1e,   0x1c, 0x1a,   0x1dd0, 0x267e,   0x28,      0x26, 0x24, 0x22, 0x20,     0x30,      0x5, 0x4, 0x1, 0x0, 0x0,   0xff, 0xff, 0xff, "[KRx ] CPS_B_21_BT4 Knights of the Round" },
  { 0xff, 0x0000,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x20,      0x2e, 0x2c, 0x2a, 0x28,     0x30,      0x5, 0x2, 0x2, 0x0, 0x0,   0xff, 0xff, 0xff, "[Q5  ] CPS_B_21_BT6 Capcom World 2" },
  { 0xff, 0x0000,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x2c,      0xff, 0xff, 0xff, 0xff,     0x12,      0x4, 0x1, 0x4, 0x0, 0x0,   0xff, 0xff, 0xff, "[QDx ] CPS_B_21_BT7 Quiz & Dragons" },
  { 0x32, 0x0800,   0x0e, 0x0c, 0x0a, 0x08, 0x06,   0x04, 0x02,   0x1b3d, 0x0e6b,   0x28,      0x26, 0x24, 0x22, 0x20,     0x30,      0x5, 0x2, 0x3, 0x0, 0x0,   0xff, 0xff, 0xff, "[RTx ] CPS_B_21_BT1 Three Wonders" },
  { 0x32, 0x0000,   0x0e, 0x0c, 0x0a, 0x08, 0x1e,   0x1c, 0x1a,   0x4e71, 0x4e71,   0x20,      0x2e, 0x2c, 0x2a, 0x28,     0x30,      0x5, 0x2, 0x1, 0x0, 0x0,   0xff, 0xff, 0xff, "[VAx ] CPS_B_21_BT5 Varth" },

  // cps 1.5
  { 0xff, 0x0000,   0xff, 0xff, 0xff, 0xff, 0xff,   0x2e, 0x20,   0x49df, 0xbc52,   0x0a,      0x0c, 0x0e, 0x00, 0x02,     0x04,      0x4, 0x4, 0x4, 0x0, 0x0,   0xff, 0xff, 0xff, "[CDx ] CPS_B_21_QS2 Cadillacs & Dinosaurs" },
  { 0x2e, 0x0c01,   0xff, 0xff, 0xff, 0xff, 0x1c,   0x1e, 0x08,   0x69f4, 0xc803,   0x16,      0x00, 0x02, 0x28, 0x2a,     0x2c,      0x2, 0x3, 0x4, 0x0, 0x0,   0xff, 0xff, 0xff, "[MBx ] CPS_B_21_QS4 Slam Masters / Muscle Bomber" },
  { 0x1e, 0x0c02,   0xff, 0xff, 0xff, 0xff, 0x0c,   0xff, 0xff,   0x0000, 0x0000,   0x2a,      0x2c, 0x2e, 0x30, 0x32,     0x1c,      0x2, 0x3, 0x4, 0x0, 0x0,   0xff, 0xff, 0xff, "[MBDx] CPS_B_21_QS5 Muscle Bomber Duo" },
  { 0x0e, 0x0c00,   0xff, 0xff, 0xff, 0xff, 0x2c,   0xff, 0xff,   0x0000, 0x0000,   0x12,      0x14, 0x16, 0x08, 0x0a,     0x0c,      0x2, 0x1, 0x5, 0x0, 0x0,   0xff, 0xff, 0xff, "[PSx ] CPS_B_21_QS3 Punisher" },
  { 0xff, 0x0000,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x22,      0x24, 0x26, 0x28, 0x2a,     0x2c,      0x4, 0x3, 0x2, 0x0, 0x0,   0xff, 0xff, 0xff, "[TK2 ] CPS_B_21_QS1 Warriors of Fate" },

  // raw
  { 0xff, 0x0000,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x26,      0x28, 0x2a, 0x2c, 0x2e,     0x30,      0x1, 0x2, 0x3, 0x5, 0x5,   0xff, 0xff, 0xff, "[B-01] CPS_B_01     Forgotten Worlds / Ghouls'n Ghosts / Strider" },
  { 0x20, 0x0002,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x2c,      0x2a, 0x28, 0x26, 0x24,     0x22,      0x1, 0x2, 0x3, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-02] CPS_B_02     Dynasty Wars" },
  { 0x24, 0x0003,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x30,      0x2e, 0x2c, 0x2a, 0x28,     0x26,      0x5, 0x4, 0x3, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-03] CPS_B_03     Willow" },
  { 0x20, 0x0004,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x2e,      0x26, 0x30, 0x28, 0x32,     0x2a,      0x1, 0x2, 0x3, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-04] CPS_B_04     Final Fight" },
  { 0x20, 0x0005,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x28,      0x2a, 0x2c, 0x2e, 0x30,     0x32,      0x1, 0x3, 0x5, 0x4, 0x4,   0xff, 0xff, 0xff, "[B-05] CPS_B_05     1941" },
  { 0x32, 0x0401,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x26,      0x28, 0x2a, 0x2c, 0x2e,     0x30,      0x3, 0x4, 0x5, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-11] CPS_B_11     Area 88 / U.N. Squadron" },
  { 0x20, 0x0402,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x2c,      0x2a, 0x28, 0x26, 0x24,     0x22,      0x1, 0x2, 0x3, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-12] CPS_B_12     Mercs" },
  { 0x2e, 0x0403,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x22,      0x24, 0x26, 0x28, 0x2a,     0x2c,      0x5, 0x1, 0x2, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-13] CPS_B_13     Magic Sword" },
  { 0x1e, 0x0404,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x12,      0x14, 0x16, 0x18, 0x1a,     0x1c,      0x3, 0x5, 0x4, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-14] CPS_B_14     Mega Twins / Chiki Chiki Boys / sf2ui" },
  { 0x0e, 0x0405,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x02,      0x04, 0x06, 0x08, 0x0a,     0x0c,      0x2, 0x1, 0x5, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-15] CPS_B_15     Nemo" },
  { 0x00, 0x0406,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x0c,      0x0a, 0x08, 0x06, 0x04,     0x02,      0x4, 0x3, 0x3, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-16] CPS_B_16     Carrier Air Wing / U.S. Navy" },
  { 0x08, 0x0407,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x14,      0x12, 0x10, 0x0e, 0x0c,     0x0a,      0x3, 0x4, 0x1, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-17] CPS_B_17     Some older Street Figher 2s" },
  { 0x10, 0x0408,   0xff, 0xff, 0xff, 0xff, 0xff,   0xff, 0xff,   0x0000, 0x0000,   0x1c,      0x1a, 0x18, 0x16, 0x14,     0x12,      0x4, 0x3, 0x1, 0x0, 0x0,   0xff, 0xff, 0xff, "[B-18] CPS_B_18     sf2ee / sf2ue" },
  { 0x32, 0x0000,   0x00, 0x02, 0x04, 0x06, 0x08,   0x0a, 0x0c,   0x0000, 0x0000,   0x26,      0x28, 0x2a, 0x2c, 0x2e,     0x30,      0x1, 0x2, 0x3, 0x4, 0x5,   0x0e, 0x10, 0x12, "[B-21] CPS_B_21_DEF Bunch SF2s + Others / Boots" },

  // bad dsw value / zero key
  { 0x00, 0x0000,   0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00,   0x0000, 0x0000,   0x00,      0x00, 0x00, 0x00, 0x00,     0x00,      0x0, 0x0, 0x0, 0x0, 0x0,   0x00, 0x00, 0x00, "bad dsw value" },
};

int main(void) {

  printf("// This file was generated by gen-cps1-configs.\n\n");
  printf("#define CONFIG_MAX  %d\n", CONFIG_MAX);
  printf("#define CONFIG_SIZE %d\n", CONFIG_SIZE);
  printf("uint8_t chip_configs[CONFIG_MAX][CONFIG_SIZE] = {\n");

  printf("  // cps1 using programmed B-21                                                                                      12345  prom\n");
  for(int config_num = 0; config_num < CONFIG_MAX; config_num++) {
    reset_config();
    chip_config *config = &chip_configs[config_num];

    // programming the registers
    // https://www.youtube.com/watch?v=IBZc__9sM28&t=1339s
    // https://gitlab.com/loic.petit/cps2-reverse/-/blob/master/DLs/DL-0921/doc/configuration-key.md
    // data is written in serially so we need write data
    // backwards from bit 143 to bit 0
    //    bits
    // 138 - 143 = lower 6 bits of the cps id value
    // 133 - 137 = multiply factor x addr
    // 130 - 132 = layer mask #2
    // 125 - 129 = cps id addr
    // 120 - 124 = multiply factor y addr
    // 115 - 119 = palette ctrl addr
    // 110 - 114 = multiply result lsb addr
    // 105 - 109 = priority #4 addr
    // 102 - 104 = layer mask #3
    //  97 - 101 = multiply result msb addr
    //  92 -  96 = priority #3 addr
    //  87 -  91 = multiply tc addr
    //  82 -  86 = priority #2 addr
    //  66 -  81 = check #1 value
    //  63 -  65 = layer mask #5
    //  58 -  62 = check #1 addr
    //  53 -  57 = priority #1 addr
    //  37 -  52 = check #2 value
    //  32 -  36 = check #2 addr
    //  29 -  31 = layer mask #4
    //  24 -  28 = raster #1 addr
    //  19 -  23 = layer ctrl addr
    //  14 -  18 = raster #2 addr
    //   9 -  13 = raster #3 addr
    //   6 -   8 = layer mask #1
    //   0 -   5 = upper 6 bits of cps id value
    add_bits(config->cps_id_value, 6);
    add_addr(config->multi_factor_x_addr);
    add_bits(config->layer2_mask, 3);
    add_addr(config->cps_id_addr);

    add_addr(config->multi_factor_y_addr);
    add_addr(config->palette_ctrl_addr);
    add_addr(config->multi_result_lsb_addr);

    add_addr(config->priority4_addr);
    add_bits(config->layer3_mask, 3);
    add_addr(config->multi_result_msb_addr);
    add_addr(config->priority3_addr);

    add_addr(config->multi_tc_addr);
    add_addr(config->priority2_addr);
    add_bits(config->check1_value, 16);
    add_bits(config->layer5_mask, 3);

    add_addr(config->check1_addr);
    add_addr(config->priority1_addr);
    add_bits(config->check2_value, 16);
    add_addr(config->check2_addr);

    add_bits(config->layer4_mask, 3);
    add_addr(config->raster1_addr);
    add_addr(config->layer_ctrl_addr);
    add_addr(config->raster2_addr);

    add_addr(config->raster3_addr);
    add_bits(config->layer1_mask, 3);
    add_bits(config->cps_id_value >> 10, 6);

    printf("  { ");
    print_config();
    printf("}, // ");
    print_jumper(config_num);
    printf(" %s\n", config->comment);

    // little ghetto
    if(config_num == 6) {
      printf("\n  // cps1.5 using programmed B-21\n");
    } else if(config_num == 11) {
      printf("\n  // raw B-xxx chips\n");
    } else if(config_num == CONFIG_MAX - 2) {
      printf("\n");
    }
  }

  printf("};\n");
}

void print_jumper(uint8_t value) {
  for(int i = 4; i >= 0; i--) {
    if(value & masks[i]) {
      printf("1");
    } else {
      printf("0");
    }
  }
}

void reset_config() {
  config_raw_byte = 0;
  config_raw_offset = 0;
  config_raw_bits = 0;
  for(int i = 0;i < CONFIG_SIZE;i++) {
    config_raw[i] = 0;
  }
}

void add_addr(uint8_t addr) {
  add_bits(addr >> 1, 5);
}

void add_bits(uint16_t data, int8_t num_bits) {
  num_bits--;
  while(num_bits >= 0) {
    config_raw[config_raw_offset] = config_raw[config_raw_offset] << 1;

    uint16_t bit = data & masks[num_bits];
    if(bit) {
      config_raw[config_raw_offset] = config_raw[config_raw_offset] | 0x1;
    }

    config_raw_bits++;
    if(config_raw_bits == 8) {
      config_raw_offset++;
      config_raw_bits = 0;
    }
    num_bits--;
  }
}

void print_config(void) {
  for(int i = 0;i < CONFIG_SIZE;i++) {
    printf("0x%02x%s", config_raw[i], i == CONFIG_SIZE - 1 ? " " : ", ");
  }
}
